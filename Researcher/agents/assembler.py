import os
from datetime import datetime
from markdown_pdf import MarkdownPdf, Section

from agents import ResearchState
from utils import get_logger


class AssemblerAgent:
    def __init__(self, **convertor_kwargs):
        """Integrates all validated sections into a unified document. Produces the final **PDF report** with a Title page, abstract, table of contents, Main body, conclusion, references, appendix, and consistent styling.
        """
        self.logger = get_logger(self.__class__.__name__)
        self.pdf = MarkdownPdf(**convertor_kwargs)
        self.css = 'body {text-align: justify}'

        self.logger.info('AssemblerAgent Initialised.')

    # --------------------------------------------------------
    # most of functions are self-explanatory, so no docstrings
    # --------------------------------------------------------
    
    def set_meta_data(self, state: ResearchState) -> None:
        self.pdf.meta['creationDate'] = datetime.now().strftime('%Y-%m-%d')
        self.pdf.meta['producer'] = 'AI Research Assistant'
        self.pdf.meta['title'] = f'A Research Report on {state.get('topic', 'Untitled')}'
        self.pdf.meta['author'] = 'Harshit Kumawat'
        self.logger.info('Successfully generated meta data for the pdf.')


    def add_title_page(self) -> None:
        self.pdf.add_section(Section(
            f'# {self.pdf.meta['title']}'
            '\n\n'
            f'**Author:** {self.pdf.meta['author']} (Created using Agentic AI Pipeline)<br>'
            '**Disclamer:** This report is auto-generated by an AI-powered research assistant. Human verification is recommended for critical use.<br>'
            f'**Date of Creation:** {self.pdf.meta['creationDate']}<br>'
            '<hr>'
        ))
        self.logger.info('Created the title page.')

    
    def add_abstract(self, abstract: str) -> None:
        self.pdf.add_section(
            Section(text= f'## Abstract\n\n{abstract}', toc= False),
            self.css
        )
        self.logger.info('Added Abstract.')


    def add_methodology(self) -> None:
        path = os.path.join('utils', 'methodology.txt')
        with open(path) as f:
            methodology = f.read()

        self.pdf.add_section(
            Section(methodology),
            self.css
        )
        self.logger.info('Added Methodology.')


    def add_main_body(self, report_parts: list[str]) -> None:
        main_body = '\n\n'.join(report_parts)
        self.pdf.add_section(
            Section(main_body),
            self.css
        )
        self.logger.info('Added main body.')


    def add_conclusion(self, conclusion: str) -> None:
        self.pdf.add_section(
            Section(f'## Conclusion\n\n{conclusion}'),
            self.css
        )
        self.logger.info('Added conclusion.')


    @staticmethod
    def _format_authors(authors: list[str]) -> str:
        """Converts the `authors` list into a structured string, resembling IEEE/Vancouver standards."""
        if not authors:
            return ''

        formatted = []
        for name in authors:
            parts = name.split()

            if len(parts) == 1:
                formatted.append(parts[0])

            # author is "Wikipedia Contributers" so conversion doesn't make sense
            elif 'wikipedia' in name.lower():
                formatted.append(name)

            else:
                # "Harshit Kumawat" -> "H. Kumawat"
                initials = ' '.join([p[0] + '.' for p in parts[:-1]])
                formatted.append(f'{initials} {parts[-1]}')

        if len(formatted) == 1:
            return formatted[0]
        
        elif len(formatted) == 2:
            return f'{formatted[0]} and {formatted[1]}'
        
        else:
            # e.g. -> C. H. Song, H. J. Han, and Y. Avrithis,
            return ', '.join(formatted[:-1]) + f', and {formatted[-1]}'
        

    def add_references(self, sources: list[dict]) -> None:
        references = []
        self.logger.info('Creating IEEE / Vancouver styled references...')

        for source in sources:
            authors = self._format_authors(source['authors'])

            # reference template: [id] Author(s), [title], [source], [Online]. Available: [url]
            reference = (
                f"[{source['id']}] "
                f"{authors}, "
                f"\"{source['title']}\", "
                f"{source['source']}, [Online]. "
                f"Available: [{source['url']}]({source['url']})"
            )
            references.append(reference)
            self.logger.info(f'Created reference for source ID: {source['id']}')

        self.pdf.add_section(Section(f'## References\n\n{"\n\n".join(references)}'))
        self.logger.info('Added references.')


    def add_appendix_a(self, topics: dict) -> None:
        """Adds the knowledge base that was extracted earlier."""

        appendix = []
        self.logger.info('Creating Appendix A: Key points of Report...')

        for index, topic in enumerate(topics, start= 1):
            # adding every summary point of topic as valid markdown bullet points
            heading = f'{index}. **{topic['title']}:**\n\t- '
            summary = '\n\t- '.join(b for b in topic['summary_points'])
            self.logger.info(f'Extracted main summary of topic {topic['title']}.')

            subtopics = []
            for index, subtopic in enumerate(topic.get('subtopics', []), start= 1):
                # adding every subtopic's summary points into the topic's summary points
                bullets = '\n\t- '.join(b for b in subtopic['summary_points'])
                subtopics.append('\n\t- ' + bullets)
                self.logger.info(f'Extracted summary of subtopic {index}.')

            subtopic_bullets = '\n'.join(subtopics)

            # combining all points (topic + summary points)
            appendix.append(heading + summary + subtopic_bullets)
            self.logger.info(f'Combined heading, summary and subtopic summary.')

        self.pdf.add_section(Section(f'## Appendix A: Key points of Report\n\n{"\n".join(appendix)}'))
        self.logger.info('Added Apendix A.')
        

    def add_appendix_b(self, news_list: list[dict]) -> None:
        """Adds the Recent News."""
        appendix = []
        self.logger.info('Creating Appendix B: Recent News...')

        # News template: 
        # Title
        #   - Publisher - Published on [date]
        #   - For more details click here.

        for news in news_list:
            title = f'- **{news['title']}**'
            publisher = f'\n\t- {news['publisher']['title']} - Published on {news['published date']}'
            url = f'\n\t- [For more details click here.]({news['url']})'

            appendix.append(title + publisher + url)
            self.logger.info(f'Extracted news: {news['title']}')


        self.pdf.add_section(Section(f'## Appendix B: Recent News\n\n{"\n".join(appendix)}'))
        self.logger.info('Added Apendix B.')


    def save(self, file_name: str) -> None:
        os.makedirs('results', exist_ok= True)
        path = os.path.join('results', file_name)
        self.pdf.save(path)
        self.logger.info(f'Saved the final report at: {path}')


    def create_final_pdf(self, state: ResearchState) -> None:
        """
        Generates the final structured research report as a PDF.

        This method assembles all components of the research pipeline (produced by Searcher, Extractor, Writer, and Critic agents) into a professionally formatted PDF document. It sequentially builds the report with title page, abstract, methodology, main body, conclusion, references, and appendices.

        Args:
            state (ResearchState): The complete research state containing:
                - topic (str): Research topic for the title page and filename.
                - knowledge (dict): Extracted knowledge with fields:
                    * abstract (str): Abstract text for the report.
                    * conclusion (str): Conclusion text.
                    * sources (list[dict]): List of references in structured format.
                    * topics (list[dict]): Topics and subtopics for Appendix A.
                - report_parts (list[str]): Expanded content sections for the main body.
                - news (list[dict]): Recent news items about the topic for Appendix B.

        ## Workflow:
            1. Set document metadata (title, author, date, etc.).
            2. Add the title page.
            3. Insert abstract.
            4. Insert methodology section.
            5. Compile the main body using generated report parts.
            6. Add conclusion.
            7. Format and append references in citation style.
            8. Add Appendix A (structured knowledge summary).
            9. Add Appendix B (recent news with metadata).
            10. Save the completed PDF.

        ## Output:
            Saves the final PDF to disk with the filename: "topic.pdf".
        """
        self.set_meta_data(state)
        self.add_title_page()
        self.add_abstract(state.get('knowledge')['abstract'])
        self.add_methodology()
        self.add_main_body(state.get('report_parts', []))
        self.add_conclusion(state.get('knowledge')['conclusion'])
        self.add_references(state.get('knowledge')['sources'])
        self.add_appendix_a(state.get('knowledge')['topics'])
        self.add_appendix_b(state.get('news', []))

        self.save(f"{state.get('topic', 'Untitled')}.pdf")
